{"ast":null,"code":"'use strict';\n\nvar casing = require('./util/casing.js');\nvar normalize = require('./util/normalize.js');\nvar flag = require('./util/flag.js');\nvar form = require('./util/form.js');\nmodule.exports = suggest;\nvar push = [].push;\n\n// Suggest spelling for `value`.\n// eslint-disable-next-line complexity\nfunction suggest(value) {\n  var self = this;\n  var charAdded = {};\n  var suggestions = [];\n  var weighted = {};\n  var memory;\n  var replacement;\n  var edits = [];\n  var values;\n  var index;\n  var offset;\n  var position;\n  var count;\n  var otherOffset;\n  var otherCharacter;\n  var character;\n  var group;\n  var before;\n  var after;\n  var upper;\n  var insensitive;\n  var firstLevel;\n  var previous;\n  var next;\n  var nextCharacter;\n  var max;\n  var distance;\n  var size;\n  var normalized;\n  var suggestion;\n  var currentCase;\n  value = normalize(value.trim(), self.conversion.in);\n  if (!value || self.correct(value)) {\n    return [];\n  }\n  currentCase = casing(value);\n\n  // Check the replacement table.\n  index = -1;\n  while (++index < self.replacementTable.length) {\n    replacement = self.replacementTable[index];\n    offset = value.indexOf(replacement[0]);\n    while (offset > -1) {\n      edits.push(value.replace(replacement[0], replacement[1]));\n      offset = value.indexOf(replacement[0], offset + 1);\n    }\n  }\n\n  // Check the keyboard.\n  index = -1;\n  while (++index < value.length) {\n    character = value.charAt(index);\n    before = value.slice(0, index);\n    after = value.slice(index + 1);\n    insensitive = character.toLowerCase();\n    upper = insensitive !== character;\n    charAdded = {};\n    offset = -1;\n    while (++offset < self.flags.KEY.length) {\n      group = self.flags.KEY[offset];\n      position = group.indexOf(insensitive);\n      if (position < 0) {\n        continue;\n      }\n      otherOffset = -1;\n      while (++otherOffset < group.length) {\n        if (otherOffset !== position) {\n          otherCharacter = group.charAt(otherOffset);\n          if (charAdded[otherCharacter]) {\n            continue;\n          }\n          charAdded[otherCharacter] = true;\n          if (upper) {\n            otherCharacter = otherCharacter.toUpperCase();\n          }\n          edits.push(before + otherCharacter + after);\n        }\n      }\n    }\n  }\n\n  // Check cases where one of a double character was forgotten, or one too many\n  // were added, up to three “distances”.  This increases the success-rate by 2%\n  // and speeds the process up by 13%.\n  index = -1;\n  nextCharacter = value.charAt(0);\n  values = [''];\n  max = 1;\n  distance = 0;\n  while (++index < value.length) {\n    character = nextCharacter;\n    nextCharacter = value.charAt(index + 1);\n    before = value.slice(0, index);\n    replacement = character === nextCharacter ? '' : character + character;\n    offset = -1;\n    count = values.length;\n    while (++offset < count) {\n      if (offset <= max) {\n        values.push(values[offset] + replacement);\n      }\n      values[offset] += character;\n    }\n    if (++distance < 3) {\n      max = values.length;\n    }\n  }\n  push.apply(edits, values);\n\n  // Ensure the capitalised and uppercase values are included.\n  values = [value];\n  replacement = value.toLowerCase();\n  if (value === replacement || currentCase === null) {\n    values.push(value.charAt(0).toUpperCase() + replacement.slice(1));\n  }\n  replacement = value.toUpperCase();\n  if (value !== replacement) {\n    values.push(replacement);\n  }\n\n  // Construct a memory object for `generate`.\n  memory = {\n    state: {},\n    weighted: weighted,\n    suggestions: suggestions\n  };\n  firstLevel = generate(self, memory, values, edits);\n\n  // While there are no suggestions based on generated values with an\n  // edit-distance of `1`, check the generated values, `SIZE` at a time.\n  // Basically, we’re generating values with an edit-distance of `2`, but were\n  // doing it in small batches because it’s such an expensive operation.\n  previous = 0;\n  max = Math.min(firstLevel.length, Math.pow(Math.max(15 - value.length, 3), 3));\n  size = Math.max(Math.pow(10 - value.length, 3), 1);\n  while (!suggestions.length && previous < max) {\n    next = previous + size;\n    generate(self, memory, firstLevel.slice(previous, next));\n    previous = next;\n  }\n\n  // Sort the suggestions based on their weight.\n  suggestions.sort(sort);\n\n  // Normalize the output.\n  values = [];\n  normalized = [];\n  index = -1;\n  while (++index < suggestions.length) {\n    suggestion = normalize(suggestions[index], self.conversion.out);\n    replacement = suggestion.toLowerCase();\n    if (normalized.indexOf(replacement) < 0) {\n      values.push(suggestion);\n      normalized.push(replacement);\n    }\n  }\n\n  // BOOM! All done!\n  return values;\n  function sort(a, b) {\n    return sortWeight(a, b) || sortCasing(a, b) || sortAlpha(a, b);\n  }\n  function sortWeight(a, b) {\n    return weighted[a] === weighted[b] ? 0 : weighted[a] > weighted[b] ? -1 : 1;\n  }\n  function sortCasing(a, b) {\n    var leftCasing = casing(a);\n    var rightCasing = casing(b);\n    return leftCasing === rightCasing ? 0 : leftCasing === currentCase ? -1 : rightCasing === currentCase ? 1 : undefined;\n  }\n  function sortAlpha(a, b) {\n    return a.localeCompare(b);\n  }\n}\n\n// Get a list of values close in edit distance to `words`.\nfunction generate(context, memory, words, edits) {\n  var characters = context.flags.TRY;\n  var data = context.data;\n  var flags = context.flags;\n  var result = [];\n  var index = -1;\n  var word;\n  var before;\n  var character;\n  var nextCharacter;\n  var nextAfter;\n  var nextNextAfter;\n  var nextUpper;\n  var currentCase;\n  var position;\n  var after;\n  var upper;\n  var inject;\n  var offset;\n\n  // Check the pre-generated edits.\n  if (edits) {\n    while (++index < edits.length) {\n      check(edits[index], true);\n    }\n  }\n\n  // Iterate over given word.\n  index = -1;\n  while (++index < words.length) {\n    word = words[index];\n    before = '';\n    character = '';\n    nextCharacter = word.charAt(0);\n    nextAfter = word;\n    nextNextAfter = word.slice(1);\n    nextUpper = nextCharacter.toLowerCase() !== nextCharacter;\n    currentCase = casing(word);\n    position = -1;\n\n    // Iterate over every character (including the end).\n    while (++position <= word.length) {\n      before += character;\n      after = nextAfter;\n      nextAfter = nextNextAfter;\n      nextNextAfter = nextAfter.slice(1);\n      character = nextCharacter;\n      nextCharacter = word.charAt(position + 1);\n      upper = nextUpper;\n      if (nextCharacter) {\n        nextUpper = nextCharacter.toLowerCase() !== nextCharacter;\n      }\n      if (nextAfter && upper !== nextUpper) {\n        // Remove.\n        check(before + switchCase(nextAfter));\n\n        // Switch.\n        check(before + switchCase(nextCharacter) + switchCase(character) + nextNextAfter);\n      }\n\n      // Remove.\n      check(before + nextAfter);\n\n      // Switch.\n      if (nextAfter) {\n        check(before + nextCharacter + character + nextNextAfter);\n      }\n\n      // Iterate over all possible letters.\n      offset = -1;\n      while (++offset < characters.length) {\n        inject = characters[offset];\n\n        // Try uppercase if the original character was uppercased.\n        if (upper && inject !== inject.toUpperCase()) {\n          if (currentCase !== 's') {\n            check(before + inject + after);\n            check(before + inject + nextAfter);\n          }\n          inject = inject.toUpperCase();\n          check(before + inject + after);\n          check(before + inject + nextAfter);\n        } else {\n          // Add and replace.\n          check(before + inject + after);\n          check(before + inject + nextAfter);\n        }\n      }\n    }\n  }\n\n  // Return the list of generated words.\n  return result;\n\n  // Check and handle a generated value.\n  function check(value, double) {\n    var state = memory.state[value];\n    var corrected;\n    if (state !== Boolean(state)) {\n      result.push(value);\n      corrected = form(context, value);\n      state = corrected && !flag(flags, 'NOSUGGEST', data[corrected]);\n      memory.state[value] = state;\n      if (state) {\n        memory.weighted[value] = double ? 10 : 0;\n        memory.suggestions.push(value);\n      }\n    }\n    if (state) {\n      memory.weighted[value]++;\n    }\n  }\n  function switchCase(fragment) {\n    var first = fragment.charAt(0);\n    return (first.toLowerCase() === first ? first.toUpperCase() : first.toLowerCase()) + fragment.slice(1);\n  }\n}","map":{"version":3,"names":["casing","require","normalize","flag","form","module","exports","suggest","push","value","self","charAdded","suggestions","weighted","memory","replacement","edits","values","index","offset","position","count","otherOffset","otherCharacter","character","group","before","after","upper","insensitive","firstLevel","previous","next","nextCharacter","max","distance","size","normalized","suggestion","currentCase","trim","conversion","in","correct","replacementTable","length","indexOf","replace","charAt","slice","toLowerCase","flags","KEY","toUpperCase","apply","state","generate","Math","min","pow","sort","out","a","b","sortWeight","sortCasing","sortAlpha","leftCasing","rightCasing","undefined","localeCompare","context","words","characters","TRY","data","result","word","nextAfter","nextNextAfter","nextUpper","inject","check","switchCase","double","corrected","Boolean","fragment","first"],"sources":["C:/Users/khush/OneDrive/Desktop/new changes code/frontend1/node_modules/nspell/lib/suggest.js"],"sourcesContent":["'use strict'\n\nvar casing = require('./util/casing.js')\nvar normalize = require('./util/normalize.js')\nvar flag = require('./util/flag.js')\nvar form = require('./util/form.js')\n\nmodule.exports = suggest\n\nvar push = [].push\n\n// Suggest spelling for `value`.\n// eslint-disable-next-line complexity\nfunction suggest(value) {\n  var self = this\n  var charAdded = {}\n  var suggestions = []\n  var weighted = {}\n  var memory\n  var replacement\n  var edits = []\n  var values\n  var index\n  var offset\n  var position\n  var count\n  var otherOffset\n  var otherCharacter\n  var character\n  var group\n  var before\n  var after\n  var upper\n  var insensitive\n  var firstLevel\n  var previous\n  var next\n  var nextCharacter\n  var max\n  var distance\n  var size\n  var normalized\n  var suggestion\n  var currentCase\n\n  value = normalize(value.trim(), self.conversion.in)\n\n  if (!value || self.correct(value)) {\n    return []\n  }\n\n  currentCase = casing(value)\n\n  // Check the replacement table.\n  index = -1\n\n  while (++index < self.replacementTable.length) {\n    replacement = self.replacementTable[index]\n    offset = value.indexOf(replacement[0])\n\n    while (offset > -1) {\n      edits.push(value.replace(replacement[0], replacement[1]))\n      offset = value.indexOf(replacement[0], offset + 1)\n    }\n  }\n\n  // Check the keyboard.\n  index = -1\n\n  while (++index < value.length) {\n    character = value.charAt(index)\n    before = value.slice(0, index)\n    after = value.slice(index + 1)\n    insensitive = character.toLowerCase()\n    upper = insensitive !== character\n    charAdded = {}\n\n    offset = -1\n\n    while (++offset < self.flags.KEY.length) {\n      group = self.flags.KEY[offset]\n      position = group.indexOf(insensitive)\n\n      if (position < 0) {\n        continue\n      }\n\n      otherOffset = -1\n\n      while (++otherOffset < group.length) {\n        if (otherOffset !== position) {\n          otherCharacter = group.charAt(otherOffset)\n\n          if (charAdded[otherCharacter]) {\n            continue\n          }\n\n          charAdded[otherCharacter] = true\n\n          if (upper) {\n            otherCharacter = otherCharacter.toUpperCase()\n          }\n\n          edits.push(before + otherCharacter + after)\n        }\n      }\n    }\n  }\n\n  // Check cases where one of a double character was forgotten, or one too many\n  // were added, up to three “distances”.  This increases the success-rate by 2%\n  // and speeds the process up by 13%.\n  index = -1\n  nextCharacter = value.charAt(0)\n  values = ['']\n  max = 1\n  distance = 0\n\n  while (++index < value.length) {\n    character = nextCharacter\n    nextCharacter = value.charAt(index + 1)\n    before = value.slice(0, index)\n\n    replacement = character === nextCharacter ? '' : character + character\n    offset = -1\n    count = values.length\n\n    while (++offset < count) {\n      if (offset <= max) {\n        values.push(values[offset] + replacement)\n      }\n\n      values[offset] += character\n    }\n\n    if (++distance < 3) {\n      max = values.length\n    }\n  }\n\n  push.apply(edits, values)\n\n  // Ensure the capitalised and uppercase values are included.\n  values = [value]\n  replacement = value.toLowerCase()\n\n  if (value === replacement || currentCase === null) {\n    values.push(value.charAt(0).toUpperCase() + replacement.slice(1))\n  }\n\n  replacement = value.toUpperCase()\n\n  if (value !== replacement) {\n    values.push(replacement)\n  }\n\n  // Construct a memory object for `generate`.\n  memory = {\n    state: {},\n    weighted: weighted,\n    suggestions: suggestions\n  }\n\n  firstLevel = generate(self, memory, values, edits)\n\n  // While there are no suggestions based on generated values with an\n  // edit-distance of `1`, check the generated values, `SIZE` at a time.\n  // Basically, we’re generating values with an edit-distance of `2`, but were\n  // doing it in small batches because it’s such an expensive operation.\n  previous = 0\n  max = Math.min(firstLevel.length, Math.pow(Math.max(15 - value.length, 3), 3))\n  size = Math.max(Math.pow(10 - value.length, 3), 1)\n\n  while (!suggestions.length && previous < max) {\n    next = previous + size\n    generate(self, memory, firstLevel.slice(previous, next))\n    previous = next\n  }\n\n  // Sort the suggestions based on their weight.\n  suggestions.sort(sort)\n\n  // Normalize the output.\n  values = []\n  normalized = []\n  index = -1\n\n  while (++index < suggestions.length) {\n    suggestion = normalize(suggestions[index], self.conversion.out)\n    replacement = suggestion.toLowerCase()\n\n    if (normalized.indexOf(replacement) < 0) {\n      values.push(suggestion)\n      normalized.push(replacement)\n    }\n  }\n\n  // BOOM! All done!\n  return values\n\n  function sort(a, b) {\n    return sortWeight(a, b) || sortCasing(a, b) || sortAlpha(a, b)\n  }\n\n  function sortWeight(a, b) {\n    return weighted[a] === weighted[b] ? 0 : weighted[a] > weighted[b] ? -1 : 1\n  }\n\n  function sortCasing(a, b) {\n    var leftCasing = casing(a)\n    var rightCasing = casing(b)\n\n    return leftCasing === rightCasing\n      ? 0\n      : leftCasing === currentCase\n      ? -1\n      : rightCasing === currentCase\n      ? 1\n      : undefined\n  }\n\n  function sortAlpha(a, b) {\n    return a.localeCompare(b)\n  }\n}\n\n// Get a list of values close in edit distance to `words`.\nfunction generate(context, memory, words, edits) {\n  var characters = context.flags.TRY\n  var data = context.data\n  var flags = context.flags\n  var result = []\n  var index = -1\n  var word\n  var before\n  var character\n  var nextCharacter\n  var nextAfter\n  var nextNextAfter\n  var nextUpper\n  var currentCase\n  var position\n  var after\n  var upper\n  var inject\n  var offset\n\n  // Check the pre-generated edits.\n  if (edits) {\n    while (++index < edits.length) {\n      check(edits[index], true)\n    }\n  }\n\n  // Iterate over given word.\n  index = -1\n\n  while (++index < words.length) {\n    word = words[index]\n    before = ''\n    character = ''\n    nextCharacter = word.charAt(0)\n    nextAfter = word\n    nextNextAfter = word.slice(1)\n    nextUpper = nextCharacter.toLowerCase() !== nextCharacter\n    currentCase = casing(word)\n    position = -1\n\n    // Iterate over every character (including the end).\n    while (++position <= word.length) {\n      before += character\n      after = nextAfter\n      nextAfter = nextNextAfter\n      nextNextAfter = nextAfter.slice(1)\n      character = nextCharacter\n      nextCharacter = word.charAt(position + 1)\n      upper = nextUpper\n\n      if (nextCharacter) {\n        nextUpper = nextCharacter.toLowerCase() !== nextCharacter\n      }\n\n      if (nextAfter && upper !== nextUpper) {\n        // Remove.\n        check(before + switchCase(nextAfter))\n\n        // Switch.\n        check(\n          before +\n            switchCase(nextCharacter) +\n            switchCase(character) +\n            nextNextAfter\n        )\n      }\n\n      // Remove.\n      check(before + nextAfter)\n\n      // Switch.\n      if (nextAfter) {\n        check(before + nextCharacter + character + nextNextAfter)\n      }\n\n      // Iterate over all possible letters.\n      offset = -1\n\n      while (++offset < characters.length) {\n        inject = characters[offset]\n\n        // Try uppercase if the original character was uppercased.\n        if (upper && inject !== inject.toUpperCase()) {\n          if (currentCase !== 's') {\n            check(before + inject + after)\n            check(before + inject + nextAfter)\n          }\n\n          inject = inject.toUpperCase()\n\n          check(before + inject + after)\n          check(before + inject + nextAfter)\n        } else {\n          // Add and replace.\n          check(before + inject + after)\n          check(before + inject + nextAfter)\n        }\n      }\n    }\n  }\n\n  // Return the list of generated words.\n  return result\n\n  // Check and handle a generated value.\n  function check(value, double) {\n    var state = memory.state[value]\n    var corrected\n\n    if (state !== Boolean(state)) {\n      result.push(value)\n\n      corrected = form(context, value)\n      state = corrected && !flag(flags, 'NOSUGGEST', data[corrected])\n\n      memory.state[value] = state\n\n      if (state) {\n        memory.weighted[value] = double ? 10 : 0\n        memory.suggestions.push(value)\n      }\n    }\n\n    if (state) {\n      memory.weighted[value]++\n    }\n  }\n\n  function switchCase(fragment) {\n    var first = fragment.charAt(0)\n\n    return (\n      (first.toLowerCase() === first\n        ? first.toUpperCase()\n        : first.toLowerCase()) + fragment.slice(1)\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"'use strict';\n\nvar parse = require('./rule-codes.js');\nmodule.exports = affix;\nvar push = [].push;\n\n// Relative frequencies of letters in the English language.\nvar alphabet = 'etaoinshrdlcumwfgypbvkjxqz'.split('');\n\n// Expressions.\nvar whiteSpaceExpression = /\\s+/;\n\n// Defaults.\nvar defaultKeyboardLayout = ['qwertzuop', 'yxcvbnm', 'qaw', 'say', 'wse', 'dsx', 'sy', 'edr', 'fdc', 'dx', 'rft', 'gfv', 'fc', 'tgz', 'hgb', 'gv', 'zhu', 'jhn', 'hb', 'uji', 'kjm', 'jn', 'iko', 'lkm'];\n\n// Parse an affix file.\n// eslint-disable-next-line complexity\nfunction affix(doc) {\n  var rules = Object.create(null);\n  var compoundRuleCodes = Object.create(null);\n  var flags = Object.create(null);\n  var replacementTable = [];\n  var conversion = {\n    in: [],\n    out: []\n  };\n  var compoundRules = [];\n  var aff = doc.toString('utf8');\n  var lines = [];\n  var last = 0;\n  var index = aff.indexOf('\\n');\n  var parts;\n  var line;\n  var ruleType;\n  var count;\n  var remove;\n  var add;\n  var source;\n  var entry;\n  var position;\n  var rule;\n  var value;\n  var offset;\n  var character;\n  flags.KEY = [];\n\n  // Process the affix buffer into a list of applicable lines.\n  while (index > -1) {\n    pushLine(aff.slice(last, index));\n    last = index + 1;\n    index = aff.indexOf('\\n', last);\n  }\n  pushLine(aff.slice(last));\n\n  // Process each line.\n  index = -1;\n  while (++index < lines.length) {\n    line = lines[index];\n    parts = line.split(whiteSpaceExpression);\n    ruleType = parts[0];\n    if (ruleType === 'REP') {\n      count = index + parseInt(parts[1], 10);\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression);\n        replacementTable.push([parts[1], parts[2]]);\n      }\n      index--;\n    } else if (ruleType === 'ICONV' || ruleType === 'OCONV') {\n      count = index + parseInt(parts[1], 10);\n      entry = conversion[ruleType === 'ICONV' ? 'in' : 'out'];\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression);\n        entry.push([new RegExp(parts[1], 'g'), parts[2]]);\n      }\n      index--;\n    } else if (ruleType === 'COMPOUNDRULE') {\n      count = index + parseInt(parts[1], 10);\n      while (++index <= count) {\n        rule = lines[index].split(whiteSpaceExpression)[1];\n        position = -1;\n        compoundRules.push(rule);\n        while (++position < rule.length) {\n          compoundRuleCodes[rule.charAt(position)] = [];\n        }\n      }\n      index--;\n    } else if (ruleType === 'PFX' || ruleType === 'SFX') {\n      count = index + parseInt(parts[3], 10);\n      rule = {\n        type: ruleType,\n        combineable: parts[2] === 'Y',\n        entries: []\n      };\n      rules[parts[1]] = rule;\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression);\n        remove = parts[2];\n        add = parts[3].split('/');\n        source = parts[4];\n        entry = {\n          add: '',\n          remove: '',\n          match: '',\n          continuation: parse(flags, add[1])\n        };\n        if (add && add[0] !== '0') {\n          entry.add = add[0];\n        }\n        try {\n          if (remove !== '0') {\n            entry.remove = ruleType === 'SFX' ? end(remove) : remove;\n          }\n          if (source && source !== '.') {\n            entry.match = ruleType === 'SFX' ? end(source) : start(source);\n          }\n        } catch (_) {\n          // Ignore invalid regex patterns.\n          entry = null;\n        }\n        if (entry) {\n          rule.entries.push(entry);\n        }\n      }\n      index--;\n    } else if (ruleType === 'TRY') {\n      source = parts[1];\n      offset = -1;\n      value = [];\n      while (++offset < source.length) {\n        character = source.charAt(offset);\n        if (character.toLowerCase() === character) {\n          value.push(character);\n        }\n      }\n\n      // Some dictionaries may forget a character.\n      // Notably `en` forgets `j`, `x`, and `y`.\n      offset = -1;\n      while (++offset < alphabet.length) {\n        if (source.indexOf(alphabet[offset]) < 0) {\n          value.push(alphabet[offset]);\n        }\n      }\n      flags[ruleType] = value;\n    } else if (ruleType === 'KEY') {\n      push.apply(flags[ruleType], parts[1].split('|'));\n    } else if (ruleType === 'COMPOUNDMIN') {\n      flags[ruleType] = Number(parts[1]);\n    } else if (ruleType === 'ONLYINCOMPOUND') {\n      // If we add this ONLYINCOMPOUND flag to `compoundRuleCodes`, then\n      // `parseDic` will do the work of saving the list of words that are\n      // compound-only.\n      flags[ruleType] = parts[1];\n      compoundRuleCodes[parts[1]] = [];\n    } else if (ruleType === 'FLAG' || ruleType === 'KEEPCASE' || ruleType === 'NOSUGGEST' || ruleType === 'WORDCHARS') {\n      flags[ruleType] = parts[1];\n    } else {\n      // Default handling: set them for now.\n      flags[ruleType] = parts[1];\n    }\n  }\n\n  // Default for `COMPOUNDMIN` is `3`.\n  // See `man 4 hunspell`.\n  if (isNaN(flags.COMPOUNDMIN)) {\n    flags.COMPOUNDMIN = 3;\n  }\n  if (!flags.KEY.length) {\n    flags.KEY = defaultKeyboardLayout;\n  }\n\n  /* istanbul ignore if - Dictionaries seem to always have this. */\n  if (!flags.TRY) {\n    flags.TRY = alphabet.concat();\n  }\n  if (!flags.KEEPCASE) {\n    flags.KEEPCASE = false;\n  }\n  return {\n    compoundRuleCodes: compoundRuleCodes,\n    replacementTable: replacementTable,\n    conversion: conversion,\n    compoundRules: compoundRules,\n    rules: rules,\n    flags: flags\n  };\n  function pushLine(line) {\n    line = line.trim();\n\n    // Hash can be a valid flag, so we only discard line that starts with it.\n    if (line && line.charCodeAt(0) !== 35 /* `#` */) {\n      lines.push(line);\n    }\n  }\n}\n\n// Wrap the `source` of an expression-like string so that it matches only at\n// the end of a value.\nfunction end(source) {\n  return new RegExp(source + '$');\n}\n\n// Wrap the `source` of an expression-like string so that it matches only at\n// the start of a value.\nfunction start(source) {\n  return new RegExp('^' + source);\n}","map":{"version":3,"names":["parse","require","module","exports","affix","push","alphabet","split","whiteSpaceExpression","defaultKeyboardLayout","doc","rules","Object","create","compoundRuleCodes","flags","replacementTable","conversion","in","out","compoundRules","aff","toString","lines","last","index","indexOf","parts","line","ruleType","count","remove","add","source","entry","position","rule","value","offset","character","KEY","pushLine","slice","length","parseInt","RegExp","charAt","type","combineable","entries","match","continuation","end","start","_","toLowerCase","apply","Number","isNaN","COMPOUNDMIN","TRY","concat","KEEPCASE","trim","charCodeAt"],"sources":["C:/Users/khush/OneDrive/Desktop/new changes code/frontend1/node_modules/nspell/lib/util/affix.js"],"sourcesContent":["'use strict'\n\nvar parse = require('./rule-codes.js')\n\nmodule.exports = affix\n\nvar push = [].push\n\n// Relative frequencies of letters in the English language.\nvar alphabet = 'etaoinshrdlcumwfgypbvkjxqz'.split('')\n\n// Expressions.\nvar whiteSpaceExpression = /\\s+/\n\n// Defaults.\nvar defaultKeyboardLayout = [\n  'qwertzuop',\n  'yxcvbnm',\n  'qaw',\n  'say',\n  'wse',\n  'dsx',\n  'sy',\n  'edr',\n  'fdc',\n  'dx',\n  'rft',\n  'gfv',\n  'fc',\n  'tgz',\n  'hgb',\n  'gv',\n  'zhu',\n  'jhn',\n  'hb',\n  'uji',\n  'kjm',\n  'jn',\n  'iko',\n  'lkm'\n]\n\n// Parse an affix file.\n// eslint-disable-next-line complexity\nfunction affix(doc) {\n  var rules = Object.create(null)\n  var compoundRuleCodes = Object.create(null)\n  var flags = Object.create(null)\n  var replacementTable = []\n  var conversion = {in: [], out: []}\n  var compoundRules = []\n  var aff = doc.toString('utf8')\n  var lines = []\n  var last = 0\n  var index = aff.indexOf('\\n')\n  var parts\n  var line\n  var ruleType\n  var count\n  var remove\n  var add\n  var source\n  var entry\n  var position\n  var rule\n  var value\n  var offset\n  var character\n\n  flags.KEY = []\n\n  // Process the affix buffer into a list of applicable lines.\n  while (index > -1) {\n    pushLine(aff.slice(last, index))\n    last = index + 1\n    index = aff.indexOf('\\n', last)\n  }\n\n  pushLine(aff.slice(last))\n\n  // Process each line.\n  index = -1\n\n  while (++index < lines.length) {\n    line = lines[index]\n    parts = line.split(whiteSpaceExpression)\n    ruleType = parts[0]\n\n    if (ruleType === 'REP') {\n      count = index + parseInt(parts[1], 10)\n\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression)\n        replacementTable.push([parts[1], parts[2]])\n      }\n\n      index--\n    } else if (ruleType === 'ICONV' || ruleType === 'OCONV') {\n      count = index + parseInt(parts[1], 10)\n      entry = conversion[ruleType === 'ICONV' ? 'in' : 'out']\n\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression)\n        entry.push([new RegExp(parts[1], 'g'), parts[2]])\n      }\n\n      index--\n    } else if (ruleType === 'COMPOUNDRULE') {\n      count = index + parseInt(parts[1], 10)\n\n      while (++index <= count) {\n        rule = lines[index].split(whiteSpaceExpression)[1]\n        position = -1\n\n        compoundRules.push(rule)\n\n        while (++position < rule.length) {\n          compoundRuleCodes[rule.charAt(position)] = []\n        }\n      }\n\n      index--\n    } else if (ruleType === 'PFX' || ruleType === 'SFX') {\n      count = index + parseInt(parts[3], 10)\n\n      rule = {\n        type: ruleType,\n        combineable: parts[2] === 'Y',\n        entries: []\n      }\n\n      rules[parts[1]] = rule\n\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression)\n        remove = parts[2]\n        add = parts[3].split('/')\n        source = parts[4]\n\n        entry = {\n          add: '',\n          remove: '',\n          match: '',\n          continuation: parse(flags, add[1])\n        }\n\n        if (add && add[0] !== '0') {\n          entry.add = add[0]\n        }\n\n        try {\n          if (remove !== '0') {\n            entry.remove = ruleType === 'SFX' ? end(remove) : remove\n          }\n\n          if (source && source !== '.') {\n            entry.match = ruleType === 'SFX' ? end(source) : start(source)\n          }\n        } catch (_) {\n          // Ignore invalid regex patterns.\n          entry = null\n        }\n\n        if (entry) {\n          rule.entries.push(entry)\n        }\n      }\n\n      index--\n    } else if (ruleType === 'TRY') {\n      source = parts[1]\n      offset = -1\n      value = []\n\n      while (++offset < source.length) {\n        character = source.charAt(offset)\n\n        if (character.toLowerCase() === character) {\n          value.push(character)\n        }\n      }\n\n      // Some dictionaries may forget a character.\n      // Notably `en` forgets `j`, `x`, and `y`.\n      offset = -1\n\n      while (++offset < alphabet.length) {\n        if (source.indexOf(alphabet[offset]) < 0) {\n          value.push(alphabet[offset])\n        }\n      }\n\n      flags[ruleType] = value\n    } else if (ruleType === 'KEY') {\n      push.apply(flags[ruleType], parts[1].split('|'))\n    } else if (ruleType === 'COMPOUNDMIN') {\n      flags[ruleType] = Number(parts[1])\n    } else if (ruleType === 'ONLYINCOMPOUND') {\n      // If we add this ONLYINCOMPOUND flag to `compoundRuleCodes`, then\n      // `parseDic` will do the work of saving the list of words that are\n      // compound-only.\n      flags[ruleType] = parts[1]\n      compoundRuleCodes[parts[1]] = []\n    } else if (\n      ruleType === 'FLAG' ||\n      ruleType === 'KEEPCASE' ||\n      ruleType === 'NOSUGGEST' ||\n      ruleType === 'WORDCHARS'\n    ) {\n      flags[ruleType] = parts[1]\n    } else {\n      // Default handling: set them for now.\n      flags[ruleType] = parts[1]\n    }\n  }\n\n  // Default for `COMPOUNDMIN` is `3`.\n  // See `man 4 hunspell`.\n  if (isNaN(flags.COMPOUNDMIN)) {\n    flags.COMPOUNDMIN = 3\n  }\n\n  if (!flags.KEY.length) {\n    flags.KEY = defaultKeyboardLayout\n  }\n\n  /* istanbul ignore if - Dictionaries seem to always have this. */\n  if (!flags.TRY) {\n    flags.TRY = alphabet.concat()\n  }\n\n  if (!flags.KEEPCASE) {\n    flags.KEEPCASE = false\n  }\n\n  return {\n    compoundRuleCodes: compoundRuleCodes,\n    replacementTable: replacementTable,\n    conversion: conversion,\n    compoundRules: compoundRules,\n    rules: rules,\n    flags: flags\n  }\n\n  function pushLine(line) {\n    line = line.trim()\n\n    // Hash can be a valid flag, so we only discard line that starts with it.\n    if (line && line.charCodeAt(0) !== 35 /* `#` */) {\n      lines.push(line)\n    }\n  }\n}\n\n// Wrap the `source` of an expression-like string so that it matches only at\n// the end of a value.\nfunction end(source) {\n  return new RegExp(source + '$')\n}\n\n// Wrap the `source` of an expression-like string so that it matches only at\n// the start of a value.\nfunction start(source) {\n  return new RegExp('^' + source)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
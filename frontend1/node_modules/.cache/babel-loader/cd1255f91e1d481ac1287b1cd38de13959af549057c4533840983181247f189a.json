{"ast":null,"code":"'use strict';\n\nvar parseCodes = require('./rule-codes.js');\nvar add = require('./add.js');\nmodule.exports = parse;\n\n// Expressions.\nvar whiteSpaceExpression = /\\s/g;\n\n// Parse a dictionary.\nfunction parse(buf, options, dict) {\n  // Parse as lines (ignoring the first line).\n  var value = buf.toString('utf8');\n  var last = value.indexOf('\\n') + 1;\n  var index = value.indexOf('\\n', last);\n  while (index > -1) {\n    // Some dictionaries use tabs as comments.\n    if (value.charCodeAt(last) !== 9 /* `\\t` */) {\n      parseLine(value.slice(last, index), options, dict);\n    }\n    last = index + 1;\n    index = value.indexOf('\\n', last);\n  }\n  parseLine(value.slice(last), options, dict);\n}\n\n// Parse a line in dictionary.\nfunction parseLine(line, options, dict) {\n  var slashOffset = line.indexOf('/');\n  var hashOffset = line.indexOf('#');\n  var codes = '';\n  var word;\n  var result;\n\n  // Find offsets.\n  while (slashOffset > -1 && line.charCodeAt(slashOffset - 1) === 92 /* `\\` */) {\n    line = line.slice(0, slashOffset - 1) + line.slice(slashOffset);\n    slashOffset = line.indexOf('/', slashOffset);\n  }\n\n  // Handle hash and slash offsets.\n  // Note that hash can be a valid flag, so we should not just discard\n  // everything after it.\n  if (hashOffset > -1) {\n    if (slashOffset > -1 && slashOffset < hashOffset) {\n      word = line.slice(0, slashOffset);\n      whiteSpaceExpression.lastIndex = slashOffset + 1;\n      result = whiteSpaceExpression.exec(line);\n      codes = line.slice(slashOffset + 1, result ? result.index : undefined);\n    } else {\n      word = line.slice(0, hashOffset);\n    }\n  } else if (slashOffset > -1) {\n    word = line.slice(0, slashOffset);\n    codes = line.slice(slashOffset + 1);\n  } else {\n    word = line;\n  }\n  word = word.trim();\n  if (word) {\n    add(dict, word, parseCodes(options.flags, codes.trim()), options);\n  }\n}","map":{"version":3,"names":["parseCodes","require","add","module","exports","parse","whiteSpaceExpression","buf","options","dict","value","toString","last","indexOf","index","charCodeAt","parseLine","slice","line","slashOffset","hashOffset","codes","word","result","lastIndex","exec","undefined","trim","flags"],"sources":["C:/Users/khush/OneDrive/Desktop/new changes code/frontend1/node_modules/nspell/lib/util/dictionary.js"],"sourcesContent":["'use strict'\n\nvar parseCodes = require('./rule-codes.js')\nvar add = require('./add.js')\n\nmodule.exports = parse\n\n// Expressions.\nvar whiteSpaceExpression = /\\s/g\n\n// Parse a dictionary.\nfunction parse(buf, options, dict) {\n  // Parse as lines (ignoring the first line).\n  var value = buf.toString('utf8')\n  var last = value.indexOf('\\n') + 1\n  var index = value.indexOf('\\n', last)\n\n  while (index > -1) {\n    // Some dictionaries use tabs as comments.\n    if (value.charCodeAt(last) !== 9 /* `\\t` */) {\n      parseLine(value.slice(last, index), options, dict)\n    }\n\n    last = index + 1\n    index = value.indexOf('\\n', last)\n  }\n\n  parseLine(value.slice(last), options, dict)\n}\n\n// Parse a line in dictionary.\nfunction parseLine(line, options, dict) {\n  var slashOffset = line.indexOf('/')\n  var hashOffset = line.indexOf('#')\n  var codes = ''\n  var word\n  var result\n\n  // Find offsets.\n  while (\n    slashOffset > -1 &&\n    line.charCodeAt(slashOffset - 1) === 92 /* `\\` */\n  ) {\n    line = line.slice(0, slashOffset - 1) + line.slice(slashOffset)\n    slashOffset = line.indexOf('/', slashOffset)\n  }\n\n  // Handle hash and slash offsets.\n  // Note that hash can be a valid flag, so we should not just discard\n  // everything after it.\n  if (hashOffset > -1) {\n    if (slashOffset > -1 && slashOffset < hashOffset) {\n      word = line.slice(0, slashOffset)\n      whiteSpaceExpression.lastIndex = slashOffset + 1\n      result = whiteSpaceExpression.exec(line)\n      codes = line.slice(slashOffset + 1, result ? result.index : undefined)\n    } else {\n      word = line.slice(0, hashOffset)\n    }\n  } else if (slashOffset > -1) {\n    word = line.slice(0, slashOffset)\n    codes = line.slice(slashOffset + 1)\n  } else {\n    word = line\n  }\n\n  word = word.trim()\n\n  if (word) {\n    add(dict, word, parseCodes(options.flags, codes.trim()), options)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}